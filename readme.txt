第18回　北海道情報大学コンピュータプログラミングコンテスト応募作品
=====================================================

応募作品
----------------------------------------

* 作品の題名：超低速プロキシ
* 概要：Webサイト表示を必要以上に低速化するプロキシサーバ
* 使用言語：Node.js
* 動作環境：Node.js v18.0以上かつnpm v6.14.0以上


応募作品の概要
----------------------------------------

提出作品の概要を簡単に記述する．

応募者
----------------------------------------

### 代表者

* 2112097：澤井優真

動作方法
----------------------------------------

1. Nodejsをインストールした環境で以下のコマンドを実行する．

```
npm run start www.example.com
```
※ 別のホスト名を指定する場合は必ず2.の手順で自動構成を無効にしてからコマンドを打ち，再度有効にすること．


2. プロキシサーバの自動構成ファイルを設定する．
指定するURLは`http://localhost:3002/abe.pac`


3. ブラウザからアクセスする．

`http://www.example.com/` にアクセスすると，プロキシサーバを
経由して表示される．
※場合によっては表示され始めるまで数分掛かってしまうことがあるので，
しばらく放置してみること．

4. (オプション)制限速度を変更する
`http://127.0.0.1:3002/delay/1000`にGETリクエストを送ると，
一文字送信するのに1000msかかるようになる．


企画書，設計書，UML，作品説明ビデオ
----------------------------------------

なし


利用した拡張ライブラリ，およびデータ
----------------------------------------
* 名前：Node.js で https をサポートする http proxy サーバを 80行で書いた
    + 説明：80行で書かれたプロキシサーバの実装例
    + 入手場所：https://qiita.com/LightSpeedC/items/5c1edc2c974206c743f4
    + 用途：HTTPSのプロキシ実装例の参考にした


* 名前：[nodejs] A simple example how to write a proxy server piping server request to client request / client response back to server response.
    + 説明：シンプルなプロキシの実装例
    + 入手場所：https://gist.github.com/bhongy/2e6f0a9f9932ab6d1c43b013a7ad773a
    + 用途：プロキシサーバの実装を参考にした

作品に関する詳しい解説
----------------------------------------

* 作品のコンセプト

コンセプトは必要以上に超低速でWebサイトを表示できるプロキシサーバである．
低速プロキシは既に存在するが，極限までに遅くできるプロキシを作れば面白いものになるのではないかと考えて作成した．
本ツールはプロトコルの限界を超えた遅さを実現し，
Webサイトのレンダリング，画像の表示，DOMツリーの構築の過程を視覚的に体験することができる．
Webブラウザは表示を高速化するために並列リクエストやキャッシュを利用しているが，
本ツールはそれらの機能を無効化することでWebブラウザの動作の理解を深めることができる．
ブラウザの動作を学習したり，低速回線や高負荷環境でのWebサイトの表示を試験することに転用が可能だ．


* 新規性

16bpsを超えてWebサイトを遅く表示できるツールは他にない．
なぜなら回線速度が16bpsを下回るとTCPコネクションが確立できないからである．
本ツールはブラウザがサーバーとの接続を確立させた後
TCPより上位のレベルで速度を制限するためタイムアウトを起さない点で従来のツールと異なる．
この目に見える表示の遅さは他のツールでは実現できない．


* 作り込み

低速化にかけては徹底的に作り込んだので主要な機能を紹介する．
モダンなブラウザはWebサイトの表示を高速化するために
DOMツリーを構築しながら並列にリクエストする．
そのため本ツールはMutexを利用して並列リクエストを
一つ一つ処理して読み込み時間を長くしている．
また，ブラウザがWebサイトをキャッシュしないようにするためにHTTPヘッダの書き換えも行う．
HTTPS通信の場合はHTTPヘッダの書き換えは行えないため，ブラウザ側でキャッシュを無効にする必要がある．

いくつかの定数を変更することで通信速度を変更できる．
BYTE_MULTIPLIERは一度に送信するバイト数を指定できる．
DELAY_PER_BYTEは一文字送信するのにかかる時間を指定できる．
TOTAL_BYTESにサイトのバイト数、ESTIMATE_TIME_MSECに表示にかかる時間を指定すると，
自動的に適切なDELAY_PER_BYTEが設定される．


* 技術要素

TCPレベルの速度制限を行うために，フレームワークではなく
Node.js標準のhttpモジュールとTCPソケットを利用した．
また，実行環境の制約が緩いNode.jsを利用して実装した．
JavaScriptは基本的にコールバック関数を用いて非同期通信を行うので，
非同期的なネットワークリクエストをハンドルするのに適している．
HTTP通信は文字通り一文字ずつ送信することができるが，
HTTPS通信の場合はTLSで暗号化されるため復号できるある程度の暗号ブロックがクライアントに到着するまで
ブラウザに表示されない．
証明書を利用して透過プロキシを実装することもできるが，
設定項目が増えるため採用しなかった．


* プログラムの設計

画像の転送時にHTTPデータを文字列として扱うと，
Nodejsの内部エンコードに勝手に変換されてしまうため，
8bitのint配列として扱えるようにする作業が大変だった．
元の画像とプロキシ後の画像をバイナリで比較して
原因が内部エンコードだったことに気付くまでに時間がかかってしまった．

また，一文字ずつデータを切り分けて送信する処理の実装にも時間がかかっている．
TCPはストリーム型のプロトコルなので，受信するデータは複数の塊で送られてくるが，
一文字ずつ送信するには塊をキューに追加し分割して順番に送信する必要がある．
JavaScriptはイベントをトリガーに関数を呼び出すので，
一文字ずつ送信する，一つしか存在できないループ処理と相性が悪い．
最終的にHTTPリクエストのコールバックのネストでバッファーを作成し，
一文字ずつ送信する非同期関数からバッファーを読み込むことで実装できた．
例えばAjaxや動的なWebコンテンツではHTTPレスポンスが複数パケットに渡ることがあるが，
この実装のおかげでレスポンスが複数のパケットでも常に一文字ずつ送信することができる．


* ソースコード

TCPレベルの操作ができる外部ライブラリを見つけられなかったため，
本ツールは標準ライブラリのみで実装している．
そのためプリミティブな記述が増え，記述が膨大になった．
可読性を良くするためにこまめなコメントを心がけ，
コールバックのネストが増えすぎないように気を付けた．
ただ，JavaScriptは一般的に可読性が低くなりがちなので，
TypeScriptを使ってクラス化するべきだったかもしれないと反省している．
